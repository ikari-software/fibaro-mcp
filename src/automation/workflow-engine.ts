/**
 * Fibaro MCP Server - Workflow Engine
 *
 * Copyright (c) 2025 Cezar "ikari" Pokorski
 * Licensed under the MIT License
 */

import { logger } from "../logger.js";
import { getConditionBuilder } from "./condition-builder.js";
import type {
  Automation,
  Action,
  AutomationResult,
  ValidationResult,
} from "./automation-types.js";

export class WorkflowEngine {
  private conditionBuilder = getConditionBuilder();

  /**
   * Generate Lua scene code from automation definition
   */
  generateLuaCode(automation: Automation): string {
    logger.debug(`Generating Lua code for automation: ${automation.name}`);

    // Validate automation first
    const validation = this.validateAutomation(automation);
    if (!validation.valid) {
      throw new Error(`Invalid automation: ${validation.errors.join(", ")}`);
    }

    const parts: string[] = [];

    // Header comment
    parts.push(`--[[`);
    parts.push(`  Automation: ${automation.name}`);
    if (automation.description) {
      parts.push(`  Description: ${automation.description}`);
    }
    parts.push(`  Generated by Fibaro MCP Server`);
    parts.push(`]]`);
    parts.push("");

    // Main function
    parts.push("local function automation_main()");

    // Condition check
    parts.push("  -- Check conditions");
    const conditionCode = this.conditionBuilder.buildConditionGroup(automation.conditions);
    parts.push(`  if ${conditionCode} then`);

    // Actions
    parts.push("    -- Execute actions");
    parts.push(`    fibaro.debug("[${automation.name}] Conditions met, executing actions")`);

    for (let i = 0; i < automation.actions.length; i++) {
      const action = automation.actions[i];
      const actionCode = this.buildAction(action, i);
      parts.push("");
      parts.push(`    -- Action ${i + 1}: ${action.type}`);
      parts.push(actionCode.split("\n").map((line) => "    " + line).join("\n"));
    }

    parts.push("  else");
    parts.push(`    fibaro.debug("[${automation.name}] Conditions not met, skipping actions")`);
    parts.push("  end");
    parts.push("end");
    parts.push("");

    // Error handling wrapper
    parts.push("-- Execute with error handling");
    parts.push("local success, err = pcall(automation_main)");
    parts.push("if not success then");
    parts.push(`  fibaro.debug("[${automation.name}] ERROR: " .. tostring(err))`);
    parts.push("end");

    return parts.join("\n");
  }

  /**
   * Create automation from definition and optionally deploy to Fibaro
   */
  async createAutomation(
    client: any,
    automation: Automation,
    deploy: boolean = false
  ): Promise<AutomationResult> {
    logger.info(`Creating automation: ${automation.name}`);

    // Validate automation
    const validation = this.validateAutomation(automation);

    if (!validation.valid) {
      return {
        automation,
        luaCode: "",
        validation,
      };
    }

    // Generate Lua code
    const luaCode = this.generateLuaCode(automation);

    // Deploy to Fibaro if requested
    let sceneId: number | undefined;
    if (deploy) {
      try {
        const scene = await client.createScene({
          name: automation.name,
          roomID: 1, // Default room
          lua: luaCode,
          type: "lua",
          isLua: true,
        });
        sceneId = scene.id;
        logger.info(`Automation deployed as scene ${sceneId}`);
      } catch (error) {
        validation.errors.push(
          `Failed to deploy: ${error instanceof Error ? error.message : String(error)}`
        );
        validation.valid = false;
      }
    }

    return {
      automation,
      luaCode,
      sceneId,
      validation,
    };
  }

  /**
   * Validate automation definition
   */
  validateAutomation(automation: Automation): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Basic validation
    if (!automation.name) {
      errors.push("Automation must have a name");
    }

    if (!automation.conditions) {
      errors.push("Automation must have conditions");
    } else {
      const conditionResult = this.conditionBuilder.validateConditionGroup(
        automation.conditions
      );
      errors.push(...conditionResult.errors);
      warnings.push(...conditionResult.warnings);
    }

    if (!automation.actions || automation.actions.length === 0) {
      errors.push("Automation must have at least one action");
    } else {
      for (let i = 0; i < automation.actions.length; i++) {
        const actionResult = this.validateAction(automation.actions[i]);
        errors.push(
          ...actionResult.errors.map((e) => `Action ${i + 1}: ${e}`)
        );
        warnings.push(
          ...actionResult.warnings.map((w) => `Action ${i + 1}: ${w}`)
        );
      }
    }

    // Schedule validation
    if (automation.schedule) {
      warnings.push(
        "Schedule (cron) support requires Fibaro scene triggers - not implemented in Lua code"
      );
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Validate a single action
   */
  validateAction(action: Action): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    switch (action.type) {
      case "device_action": {
        if (!action.deviceId) {
          errors.push("device_action requires deviceId");
        }
        if (!action.action) {
          errors.push("device_action requires action name");
        }
        break;
      }

      case "scene": {
        if (!action.sceneId) {
          errors.push("scene action requires sceneId");
        }
        break;
      }

      case "delay": {
        if (!action.delay || action.delay <= 0) {
          errors.push("delay action requires positive delay value (milliseconds)");
        }
        break;
      }

      case "variable_set": {
        if (!action.variableName) {
          errors.push("variable_set requires variableName");
        }
        if (action.value === undefined) {
          errors.push("variable_set requires value");
        }
        break;
      }

      case "notification": {
        if (!action.message) {
          errors.push("notification requires message");
        }
        break;
      }

      case "custom": {
        if (!action.customLua) {
          errors.push("custom action requires customLua field");
        }
        break;
      }

      default:
        errors.push(`Unknown action type: ${(action as any).type}`);
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  // Private helper methods

  private buildAction(action: Action, index: number): string {
    switch (action.type) {
      case "device_action": {
        // Use fibaro.call() for device actions
        const deviceId = action.deviceId!;
        const actionName = action.action!;
        const args = action.args || [];

        const argsStr = args.map((arg) => this.formatValue(arg)).join(", ");
        return `fibaro.call(${deviceId}, "${actionName}"${args.length > 0 ? ", " + argsStr : ""})`;
      }

      case "scene": {
        // Use fibaro.scene() to start scenes
        const sceneId = action.sceneId!;
        return `fibaro.scene("start", {${sceneId}})`;
      }

      case "delay": {
        // Use fibaro.sleep() for delays (expects milliseconds)
        const delayMs = action.delay!;
        const delaySeconds = (delayMs / 1000).toFixed(3);
        return `fibaro.sleep(${delayMs}) -- ${delaySeconds}s delay`;
      }

      case "variable_set": {
        // Use fibaro.setGlobalVariable()
        const varName = action.variableName!;
        const value = this.formatValue(action.value);
        return `fibaro.setGlobalVariable("${varName}", ${value})`;
      }

      case "notification": {
        // Use fibaro.debug() for notifications (could be enhanced with push notifications)
        const message = action.message!.replace(/"/g, '\\"');
        return `fibaro.debug("[NOTIFICATION] ${message}")`;
      }

      case "custom": {
        return action.customLua!;
      }

      default:
        return `-- Unknown action type: ${(action as any).type}`;
    }
  }

  private formatValue(value: any): string {
    if (typeof value === "string") {
      return `"${value.replace(/"/g, '\\"')}"`;
    } else if (typeof value === "boolean") {
      return value ? "true" : "false";
    } else if (typeof value === "number") {
      return String(value);
    } else if (value === null || value === undefined) {
      return "nil";
    } else {
      // Objects/arrays - convert to JSON string
      return `"${JSON.stringify(value).replace(/"/g, '\\"')}"`;
    }
  }
}

export function getWorkflowEngine(): WorkflowEngine {
  return new WorkflowEngine();
}
